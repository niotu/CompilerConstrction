
// ==========================================================================
//  GPPG error listing for yacc source file <Grammar.y - 16.10.2025 15:48:45>
// ==========================================================================
//  Version:  1.5.3
//  DateTime: 16.10.2025 15:49:53
// ==========================================================================


%using OCompiler.Lexer
%namespace OCompiler.Parser


%union {
    string str;
    int integer;
    double real;
    bool boolean;
}


%token <str> IDENTIFIER
%token <integer> INTEGER_LITERAL
%token <real> REAL_LITERAL
%token <boolean> BOOLEAN_LITERAL

%token 
    // End of file
    EOF
    
    // Keywords (in alphabetical order)
    CLASS      // class
    ELSE       // else  
    END        // end
    EXTENDS    // extends
    IF         // if
    IS         // is
    LOOP       // loop
    METHOD     // method
    RETURN     // return
    THEN       // then
    THIS       // this
    VAR        // var
    WHILE      // while

    // Operators and separators
    ASSIGN         // :=
    ARROW          // => (for short methods)
    COLON          // :
    DOT            // .
    COMMA          // ,
    
    // Brackets
    LPAREN         // (
    RPAREN         // )
    LBRACKET       // [
    RBRACKET       // ]

    // Comments (usually ignored)
    COMMENT        // // single-line comment

    // Error
    UNKNOWN         // unknown character


%start Program

%%

Program
    : ClassDeclarations EOF
    { 
        $$ = new ProgramNode((List<ClassDeclaration>)$1); 
    }
    ;

ClassDeclarations
    : ClassDeclaration
    { 
        $$ = new List<ClassDeclaration> { (ClassDeclaration)$1 }; 
    }
    | ClassDeclaration ClassDeclarations
    { 
        var list = (List<ClassDeclaration>)$2;
        list.Insert(0, (ClassDeclaration)$1);
        $$ = list;
    }
    ;

ClassDeclaration
    : CLASS ClassName Extension IS ClassBody END
    { 
        $$ = new ClassDeclaration((string)$2, (string)$3, (List<MemberDeclaration>)$5);
    }
    ;

ClassName 
    : IDENTIFIER Generic
    {
        $$ = (string)$1; 
    }
    ;

Generic 
    : /* empty*/
    {
        $$ = null;
    }
    | LBRACKET ClassName RBRACKET
    {
        $$ = (string)$2;
    }
    ;

Extension 
    : /* empty */
    {
        $$ = null;
    }
    | EXTENDS IDENTIFIER
    {
        $$ = (string)$2;
    }
    ;

ClassBody
    : MemberDeclaration
    {
        $$ = new List<MemberDeclaration> { (MemberDeclaration)$1 };
    }
    | MemberDeclaration ClassBody
    {
        var list = (List<MemberDeclaration>)$2;
        list.Insert(0, (MemberDeclaration)$1);
        $$ = list;
    }
    ;

MemberDeclaration
    : VariableDeclaration
    {
        $$ = $1;
    }
    | MethodDeclaration
    {
        $$ = $1;
    }
    | ConstructorDeclaration
    {
        $$ = $1;
    }
    ;

VariableDeclaration
    : VAR IDENTIFIER COLON Expression
    {
        $$ = new VariableDeclaration((string)$2, (ExpressionNode)$4);
    }
    ;

MethodDeclaration
    : MethodHeader OptionalMethodBody
    {
        $$ = new MethodDeclaration((MethodHeaderNode)$1, (MethodBodyNode)$2);
    }
    ;

OptionalMethodBody
    : /* empty */
    {
        $$ = null;
    }
    | MethodBody
    {
        $$ = $1;
    }
    ;
    
MethodHeader
    : METHOD IDENTIFIER OptionalParameters ReturnType
    {
        $$ = new MethodHeaderNode((string)$2, (List<ParameterDeclaration>)$3, (string)$4);
    }
    ;

OptionalParameters
    : /* empty */
    {
        $$ = new List<ParameterDeclaration>();
    }
    | Parameters
    {
        $$ = $1;
    }
    ;

ReturnType
    : /* empty */
    {
        $$ = null;
    }
    | COLON IDENTIFIER
    {
        $$ = (string)$2;
    }
    ;

MethodBody
    : IS Body END
    {
        $$ = $2;
    }
    | ARROW Expression
    {
        $$ = $2;
    }
    ;

Parameters
    : LPAREN ParameterDeclarations RPAREN
    {
        $$ = $2;
    }
    ;

ParameterDeclarations
    : ParameterDeclaration
    {
        $$ = new List<ParameterDeclaration>{ (ParameterDeclaration)$1 };
    }
    | ParameterDeclaration COMMA ParameterDeclarations
    {
        var list = (List<ParameterDeclaration>)$3;
        list.Insert(0, (ParameterDeclaration)$1);
        $$ = list;
    }
    ;

ParameterDeclaration
    : IDENTIFIER COLON ClassName
    {
        $$ = new ParameterDeclaration((string)$1, (string)$3);
    }
    ;

Body
    : VariableDeclaration
    {
        $$ = new List<Statement>{ (Statement)$1 };
    }
    | Statement
    {
        $$ = new List<Statement>{ (Statement)$1 };
    }
    ;

ConstructorDeclaration
    : THIS OptionalParameters IS Body END
    {
        $$ = new ConstructorDeclaration((List<ParameterDeclaration>)$2, (List<Statement>)$4);
    }
    ;

Statement
    : Assignment
    {
        $$ = $1;
    }
    | WhileLoop
    {
        $$ = $1;
    }
    | IfStatement
    {
        $$ = $1;
    }
    | ReturnStatement
    {
        $$ = $1;
    }
    ;

Assignment
    : IDENTIFIER ASSIGN Expression
    {
        $$ = new Assignment((string)$1, (ExpressionNode)$3);
    }
    ;

WhileLoop
    : WHILE Expression LOOP Body END
    {
        $$ = new WhileLoop((ExpressionNode)$2, (List<Statement>)$4);
    }
    ;

IfStatement
    : IF Expression THEN Body ElsePart END
    {
        $$ = new IfStatement((ExpressionNode)$2, (List<Statement>)$4, (ElsePart)$5);
    }
    ;

ElsePart
    : /* empty */
    {
        $$ = null;
    }
    | ELSE Body
    {
        $$ = new ElsePart((List<Statement>)$2);
    }
    ;

ReturnStatement
    : RETURN ReturningExpression
    {
        $$ = new ReturnStatement((ExpressionNode)$2);
    }
    ;

ReturningExpression
    : /* empty */
    {
        $$ = null;
    }
    | Expression
    {
        $$ = $1;
    }
    ;

Expression
    : Primary
    {
        $$ = $1;
    }
    | ConstructorInvocation
    {
        $$ = $1;
    }
    | FunctionalCall
    {
        $$ = $1;
    }
    | ExpressionDotSequence
    {
        $$ = $1;
    }
    ;

ExpressionDotSequence
    : Expression
    {
        $$ = new ExpressionDotSequence(new List<ExpressionNode>{ (ExpressionNode)$1 });
    }
    | Expression DOT ExpressionDotSequence
    {
        var list = (ExpressionDotSequence)$3;
        list.Expressions.Insert(0, (ExpressionNode)$1);
        $$ = list;
    }
    ;

ConstructorInvocation
    : ClassName Arguments
    {
        $$ = new ConstructorInvocation((string)$1, (List<ExpressionNode>)$2);
    }
    ;

FunctionalCall
    : Expression Arguments
    {
        $$ = new FunctionalCall((ExpressionNode)$1, (List<ExpressionNode>)$2);
    }
    ;

Arguments
    : LPAREN RPAREN
    {
        $$ = new List<ExpressionNode>();
    }
    | LPAREN ExpressionCommaSequence RPAREN
    {
        $$ = $2;
    }
    ;

ExpressionCommaSequence
    : Expression
    {
        $$ = new List<ExpressionNode>{ (ExpressionNode)$1 };
    }
    | Expression DOT ExpressionCommaSequence
    {
        var list = (List<ExpressionNode>)$3;
        list.Insert(0, (ExpressionNode)$1);
        $$ = list;
    }
    ;

Primary
    : INTEGER_LITERAL
    {
        $$ = new IntegerLiteral((int)$1);
    }
    | REAL_LITERAL
    {
        $$ = new RealLiteral((double)$1);
    }
    | BOOLEAN_LITERAL
    {
        $$ = new BooleanLiteral((bool)$1);
    }
    | THIS
    {
        $$ = new ThisExpression();
    }
    ;

%%

%%// Error: Unknown %keyword in this context
// ---------------------------------------
// ==========================================================================

