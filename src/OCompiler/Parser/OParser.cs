// This code was generated by the Gardens Point Parser Generator
// Copyright (c) Wayne Kelly, John Gough, QUT 2005-2014
// (see accompanying GPPGcopyright.rtf)

// GPPG version 1.5.3
// DateTime: 16.10.2025 13:12:20
// Input file <OParser.y - 16.10.2025 12:57:58>

// options: lines

using System;
using System.Collections.Generic;
using System.CodeDom.Compiler;
using System.Globalization;
using System.Text;
using QUT.Gppg;
using OCompiler.Lexer;

namespace OCompiler.Parser
{
public enum Tokens {error=2,EOF=3,IDENTIFIER=4,INTEGER_LITERAL=5,REAL_LITERAL=6,
    BOOLEAN_LITERAL=7,CLASS=8,ELSE=9,END=10,EXTENDS=11,IF=12,
    IS=13,LOOP=14,METHOD=15,RETURN=16,THEN=17,THIS=18,
    VAR=19,WHILE=20,ASSIGN=21,ARROW=22,COLON=23,DOT=24,
    COMMA=25,LPAREN=26,RPAREN=27,LBRACKET=28,RBRACKET=29,COMMENT=30,
    UNKNOWN=31};

public struct ValueType
#line 5 "OParser.y"
       {
    string str;
    int integer;
    double real;
    bool boolean;
}
#line default
[GeneratedCodeAttribute( "Gardens Point Parser Generator", "1.5.3")]
public class Parser: ShiftReduceParser<ValueType, LexLocation>
{
#pragma warning disable 649
  private static Dictionary<int, string> aliases;
#pragma warning restore 649
  private static Rule[] rules = new Rule[62];
  private static State[] states = new State[104];
  private static string[] nonTerms = new string[] {
      "Program", "$accept", "ClassDeclarations", "ClassDeclaration", "ClassName", 
      "Extension", "ClassBody", "Generic", "MemberDeclaration", "VariableDeclaration", 
      "MethodDeclaration", "ConstructorDeclaration", "Expression", "MethodHeader", 
      "OptionalMethodBody", "MethodBody", "OptionalParameters", "ReturnType", 
      "Parameters", "Body", "ParameterDeclarations", "ParameterDeclaration", 
      "Statement", "Assignment", "WhileLoop", "IfStatement", "ReturnStatement", 
      "ElsePart", "ReturningExpression", "Primary", "ConstructorInvocation", 
      "FunctionalCall", "ExpressionDotSequence", "Arguments", "ExpressionCommaSequence", 
      };

  static Parser() {
    states[0] = new State(new int[]{8,7},new int[]{-1,1,-3,3,-4,5});
    states[1] = new State(new int[]{3,2});
    states[2] = new State(-1);
    states[3] = new State(new int[]{3,4});
    states[4] = new State(-2);
    states[5] = new State(new int[]{8,7,3,-3},new int[]{-3,6,-4,5});
    states[6] = new State(-4);
    states[7] = new State(new int[]{4,39},new int[]{-5,8});
    states[8] = new State(new int[]{11,102,13,-9},new int[]{-6,9});
    states[9] = new State(new int[]{13,10});
    states[10] = new State(new int[]{19,16,15,80,18,97},new int[]{-7,11,-9,13,-10,15,-11,46,-14,47,-12,96});
    states[11] = new State(new int[]{10,12});
    states[12] = new State(-5);
    states[13] = new State(new int[]{19,16,15,80,18,97,10,-11},new int[]{-7,14,-9,13,-10,15,-11,46,-14,47,-12,96});
    states[14] = new State(-12);
    states[15] = new State(-13);
    states[16] = new State(new int[]{4,17});
    states[17] = new State(new int[]{23,18});
    states[18] = new State(new int[]{5,32,6,33,7,34,18,35,4,39},new int[]{-13,19,-30,31,-31,36,-5,37,-32,44,-33,45});
    states[19] = new State(new int[]{24,21,26,24,19,-16,15,-16,18,-16,10,-16,9,-16},new int[]{-34,20});
    states[20] = new State(-53);
    states[21] = new State(new int[]{5,32,6,33,7,34,18,35,4,39},new int[]{-33,22,-13,23,-30,31,-31,36,-5,37,-32,44});
    states[22] = new State(-49);
    states[23] = new State(new int[]{24,21,26,24,19,-50,15,-50,18,-50,10,-50,9,-50,14,-50,17,-50},new int[]{-34,20});
    states[24] = new State(new int[]{27,25,5,32,6,33,7,34,18,35,4,39},new int[]{-35,26,-13,28,-30,31,-31,36,-5,37,-32,44,-33,45});
    states[25] = new State(-54);
    states[26] = new State(new int[]{27,27});
    states[27] = new State(-55);
    states[28] = new State(new int[]{24,29,26,24,27,-50},new int[]{-34,20});
    states[29] = new State(new int[]{5,32,6,33,7,34,18,35,4,39},new int[]{-33,22,-35,30,-13,28,-30,31,-31,36,-5,37,-32,44});
    states[30] = new State(-57);
    states[31] = new State(-46);
    states[32] = new State(-58);
    states[33] = new State(-59);
    states[34] = new State(-60);
    states[35] = new State(-61);
    states[36] = new State(-47);
    states[37] = new State(new int[]{26,24},new int[]{-34,38});
    states[38] = new State(-52);
    states[39] = new State(new int[]{28,41,11,-7,13,-7,26,-7,29,-7,25,-7,27,-7},new int[]{-8,40});
    states[40] = new State(-6);
    states[41] = new State(new int[]{4,39},new int[]{-5,42});
    states[42] = new State(new int[]{29,43});
    states[43] = new State(-8);
    states[44] = new State(-48);
    states[45] = new State(-49);
    states[46] = new State(-14);
    states[47] = new State(new int[]{13,50,22,78,19,-18,15,-18,18,-18,10,-18},new int[]{-15,48,-16,49});
    states[48] = new State(-17);
    states[49] = new State(-19);
    states[50] = new State(new int[]{19,16,4,56,20,60,12,66,16,75},new int[]{-20,51,-10,53,-23,54,-24,55,-25,59,-26,65,-27,74});
    states[51] = new State(new int[]{10,52});
    states[52] = new State(-25);
    states[53] = new State(-31);
    states[54] = new State(-32);
    states[55] = new State(-34);
    states[56] = new State(new int[]{21,57});
    states[57] = new State(new int[]{5,32,6,33,7,34,18,35,4,39},new int[]{-13,58,-30,31,-31,36,-5,37,-32,44,-33,45});
    states[58] = new State(new int[]{24,21,26,24,10,-38,9,-38},new int[]{-34,20});
    states[59] = new State(-35);
    states[60] = new State(new int[]{5,32,6,33,7,34,18,35,4,39},new int[]{-13,61,-30,31,-31,36,-5,37,-32,44,-33,45});
    states[61] = new State(new int[]{14,62,24,21,26,24},new int[]{-34,20});
    states[62] = new State(new int[]{19,16,4,56,20,60,12,66,16,75},new int[]{-20,63,-10,53,-23,54,-24,55,-25,59,-26,65,-27,74});
    states[63] = new State(new int[]{10,64});
    states[64] = new State(-39);
    states[65] = new State(-36);
    states[66] = new State(new int[]{5,32,6,33,7,34,18,35,4,39},new int[]{-13,67,-30,31,-31,36,-5,37,-32,44,-33,45});
    states[67] = new State(new int[]{17,68,24,21,26,24},new int[]{-34,20});
    states[68] = new State(new int[]{19,16,4,56,20,60,12,66,16,75},new int[]{-20,69,-10,53,-23,54,-24,55,-25,59,-26,65,-27,74});
    states[69] = new State(new int[]{9,72,10,-41},new int[]{-28,70});
    states[70] = new State(new int[]{10,71});
    states[71] = new State(-40);
    states[72] = new State(new int[]{19,16,4,56,20,60,12,66,16,75},new int[]{-20,73,-10,53,-23,54,-24,55,-25,59,-26,65,-27,74});
    states[73] = new State(-42);
    states[74] = new State(-37);
    states[75] = new State(new int[]{5,32,6,33,7,34,18,35,4,39,10,-44,9,-44},new int[]{-29,76,-13,77,-30,31,-31,36,-5,37,-32,44,-33,45});
    states[76] = new State(-43);
    states[77] = new State(new int[]{24,21,26,24,10,-45,9,-45},new int[]{-34,20});
    states[78] = new State(new int[]{5,32,6,33,7,34,18,35,4,39},new int[]{-13,79,-30,31,-31,36,-5,37,-32,44,-33,45});
    states[79] = new State(new int[]{24,21,26,24,19,-26,15,-26,18,-26,10,-26},new int[]{-34,20});
    states[80] = new State(new int[]{4,81});
    states[81] = new State(new int[]{26,87,23,-21,13,-21,22,-21,19,-21,15,-21,18,-21,10,-21},new int[]{-17,82,-19,86});
    states[82] = new State(new int[]{23,84,13,-23,22,-23,19,-23,15,-23,18,-23,10,-23},new int[]{-18,83});
    states[83] = new State(-20);
    states[84] = new State(new int[]{4,85});
    states[85] = new State(-24);
    states[86] = new State(-22);
    states[87] = new State(new int[]{4,93},new int[]{-21,88,-22,90});
    states[88] = new State(new int[]{27,89});
    states[89] = new State(-27);
    states[90] = new State(new int[]{25,91,27,-28});
    states[91] = new State(new int[]{4,93},new int[]{-21,92,-22,90});
    states[92] = new State(-29);
    states[93] = new State(new int[]{23,94});
    states[94] = new State(new int[]{4,39},new int[]{-5,95});
    states[95] = new State(-30);
    states[96] = new State(-15);
    states[97] = new State(new int[]{26,87,13,-21},new int[]{-17,98,-19,86});
    states[98] = new State(new int[]{13,99});
    states[99] = new State(new int[]{19,16,4,56,20,60,12,66,16,75},new int[]{-20,100,-10,53,-23,54,-24,55,-25,59,-26,65,-27,74});
    states[100] = new State(new int[]{10,101});
    states[101] = new State(-33);
    states[102] = new State(new int[]{4,103});
    states[103] = new State(-10);

    for (int sNo = 0; sNo < states.Length; sNo++) states[sNo].number = sNo;

    rules[1] = new Rule(-2, new int[]{-1,3});
    rules[2] = new Rule(-1, new int[]{-3,3});
    rules[3] = new Rule(-3, new int[]{-4});
    rules[4] = new Rule(-3, new int[]{-4,-3});
    rules[5] = new Rule(-4, new int[]{8,-5,-6,13,-7,10});
    rules[6] = new Rule(-5, new int[]{4,-8});
    rules[7] = new Rule(-8, new int[]{});
    rules[8] = new Rule(-8, new int[]{28,-5,29});
    rules[9] = new Rule(-6, new int[]{});
    rules[10] = new Rule(-6, new int[]{11,4});
    rules[11] = new Rule(-7, new int[]{-9});
    rules[12] = new Rule(-7, new int[]{-9,-7});
    rules[13] = new Rule(-9, new int[]{-10});
    rules[14] = new Rule(-9, new int[]{-11});
    rules[15] = new Rule(-9, new int[]{-12});
    rules[16] = new Rule(-10, new int[]{19,4,23,-13});
    rules[17] = new Rule(-11, new int[]{-14,-15});
    rules[18] = new Rule(-15, new int[]{});
    rules[19] = new Rule(-15, new int[]{-16});
    rules[20] = new Rule(-14, new int[]{15,4,-17,-18});
    rules[21] = new Rule(-17, new int[]{});
    rules[22] = new Rule(-17, new int[]{-19});
    rules[23] = new Rule(-18, new int[]{});
    rules[24] = new Rule(-18, new int[]{23,4});
    rules[25] = new Rule(-16, new int[]{13,-20,10});
    rules[26] = new Rule(-16, new int[]{22,-13});
    rules[27] = new Rule(-19, new int[]{26,-21,27});
    rules[28] = new Rule(-21, new int[]{-22});
    rules[29] = new Rule(-21, new int[]{-22,25,-21});
    rules[30] = new Rule(-22, new int[]{4,23,-5});
    rules[31] = new Rule(-20, new int[]{-10});
    rules[32] = new Rule(-20, new int[]{-23});
    rules[33] = new Rule(-12, new int[]{18,-17,13,-20,10});
    rules[34] = new Rule(-23, new int[]{-24});
    rules[35] = new Rule(-23, new int[]{-25});
    rules[36] = new Rule(-23, new int[]{-26});
    rules[37] = new Rule(-23, new int[]{-27});
    rules[38] = new Rule(-24, new int[]{4,21,-13});
    rules[39] = new Rule(-25, new int[]{20,-13,14,-20,10});
    rules[40] = new Rule(-26, new int[]{12,-13,17,-20,-28,10});
    rules[41] = new Rule(-28, new int[]{});
    rules[42] = new Rule(-28, new int[]{9,-20});
    rules[43] = new Rule(-27, new int[]{16,-29});
    rules[44] = new Rule(-29, new int[]{});
    rules[45] = new Rule(-29, new int[]{-13});
    rules[46] = new Rule(-13, new int[]{-30});
    rules[47] = new Rule(-13, new int[]{-31});
    rules[48] = new Rule(-13, new int[]{-32});
    rules[49] = new Rule(-13, new int[]{-33});
    rules[50] = new Rule(-33, new int[]{-13});
    rules[51] = new Rule(-33, new int[]{-13,24,-33});
    rules[52] = new Rule(-31, new int[]{-5,-34});
    rules[53] = new Rule(-32, new int[]{-13,-34});
    rules[54] = new Rule(-34, new int[]{26,27});
    rules[55] = new Rule(-34, new int[]{26,-35,27});
    rules[56] = new Rule(-35, new int[]{-13});
    rules[57] = new Rule(-35, new int[]{-13,24,-35});
    rules[58] = new Rule(-30, new int[]{5});
    rules[59] = new Rule(-30, new int[]{6});
    rules[60] = new Rule(-30, new int[]{7});
    rules[61] = new Rule(-30, new int[]{18});
  }

  protected override void Initialize() {
    this.InitSpecialTokens((int)Tokens.error, (int)Tokens.EOF);
    this.InitStates(states);
    this.InitRules(rules);
    this.InitNonTerminals(nonTerms);
  }

  protected override void DoAction(int action)
  {
#pragma warning disable 162, 1522
    switch (action)
    {
        case 1: // Program : ClassDeclarations EOF
            CurrentSemanticValue = valueStack[1]; 
            break;

        case 2: // ClassDeclarations : ClassDeclaration
            CurrentSemanticValue = new List<ClassDeclaration> { (ClassDeclaration)valueStack[0] };
            break;

        case 3: // ClassDeclarations : ClassDeclaration ClassDeclarations
            {
                var list = (List<ClassDeclaration>)valueStack[1];
                list.Insert(0, (ClassDeclaration)valueStack[0]);
                CurrentSemanticValue = list;
            }
            break;

        case 4: // ClassDeclaration : CLASS ClassName Extension IS ClassBody END
            CurrentSemanticValue = new ClassDeclaration(
                (string)valueStack[1],
                (string)valueStack[2],
                (List<MemberDeclaration>)valueStack[4]);
            break;

        case 5: // ClassName : IDENTIFIER Generic
            CurrentSemanticValue = (string)valueStack[0];
            break;

        case 6: // Generic : /* empty */
            CurrentSemanticValue = null;
            break;

        case 7: // Generic : LBRACKET ClassName RBRACKET
            CurrentSemanticValue = valueStack[1]; 
            break;

        case 8: // Extension : /* empty */
            CurrentSemanticValue = null;
            break;

        case 9: // Extension : EXTENDS IDENTIFIER
            CurrentSemanticValue = (string)valueStack[1];
            break;

        case 10: // ClassBody : MemberDeclaration
            CurrentSemanticValue = new List<MemberDeclaration> { (MemberDeclaration)valueStack[0] };
            break;

        case 11: // ClassBody : MemberDeclaration ClassBody
            {
                var list = (List<MemberDeclaration>)valueStack[1];
                list.Insert(0, (MemberDeclaration)valueStack[0]);
                CurrentSemanticValue = list;
            }
            break;

        case 12: // MemberDeclaration : VariableDeclaration
            CurrentSemanticValue = valueStack[0];
            break;

        case 13: // MemberDeclaration : MethodDeclaration
            CurrentSemanticValue = valueStack[0];
            break;

        case 14: // MemberDeclaration : ConstructorDeclaration
            CurrentSemanticValue = valueStack[0];
            break;

        case 15: // VariableDeclaration : VAR IDENTIFIER COLON Expression
            CurrentSemanticValue = new VariableDeclaration(
                (string)valueStack[1],
                (ExpressionNode)valueStack[3]);
            break;

        case 16: // MethodDeclaration : MethodHeader OptionalMethodBody
            CurrentSemanticValue = new MethodDeclaration(
                (MethodHeaderNode)valueStack[0],
                (MethodBodyNode)valueStack[1]);
            break;

        case 17: // OptionalMethodBody : /* empty */
            CurrentSemanticValue = null;
            break;

        case 18: // OptionalMethodBody : MethodBody
            CurrentSemanticValue = valueStack[0];
            break;

        case 19: // MethodHeader : METHOD IDENTIFIER OptionalParameters ReturnType
            CurrentSemanticValue = new MethodHeaderNode(
                (string)valueStack[1],  // Identifier
                (List<ParameterDeclaration>)valueStack[2],
                (string)valueStack[3]   // Return type (nullable)
            );
            break;

        case 20: // OptionalParameters : /* empty */
            CurrentSemanticValue = new List<ParameterDeclaration>();
            break;

        case 21: // OptionalParameters : Parameters
            CurrentSemanticValue = valueStack[0];
            break;

        case 22: // ReturnType : /* empty */
            CurrentSemanticValue = null;
            break;

        case 23: // ReturnType : COLON IDENTIFIER
            CurrentSemanticValue = (string)valueStack[1];
            break;

        case 24: // MethodBody : IS Body END
            CurrentSemanticValue = valueStack[1];
            break;

        case 25: // MethodBody : ARROW Expression
            CurrentSemanticValue = valueStack[1];
            break;

        case 26: // Parameters : LPAREN ParameterDeclarations RPAREN
            CurrentSemanticValue = valueStack[1];
            break;

        case 27: // ParameterDeclarations : ParameterDeclaration
            CurrentSemanticValue = new List<ParameterDeclaration> { (ParameterDeclaration)valueStack[0] };
            break;

        case 28: // ParameterDeclarations : ParameterDeclaration COMMA ParameterDeclarations
            {
                var list = (List<ParameterDeclaration>)valueStack[2];
                list.Insert(0, (ParameterDeclaration)valueStack[0]);
                CurrentSemanticValue = list;
            }
            break;

        case 29: // ParameterDeclaration : IDENTIFIER COLON ClassName
            CurrentSemanticValue = new ParameterDeclaration(
                (string)valueStack[0],
                (string)valueStack[2]);
            break;

        case 30: // Body : VariableDeclaration
            CurrentSemanticValue = new List<Statement> { (Statement)valueStack[0] };
            break;

        case 31: // Body : Statement
            CurrentSemanticValue = new List<Statement> { (Statement)valueStack[0] };
            break;

        case 32: // ConstructorDeclaration : THIS OptionalParameters IS Body END
            CurrentSemanticValue = new ConstructorDeclaration(
                (List<ParameterDeclaration>)valueStack[1],
                (List<Statement>)valueStack[3]);
            break;

        case 33: // Statement : Assignment
            CurrentSemanticValue = valueStack[0];
            break;

        case 34: // Statement : WhileLoop
            CurrentSemanticValue = valueStack[0];
            break;

        case 35: // Statement : IfStatement
            CurrentSemanticValue = valueStack[0];
            break;

        case 36: // Statement : ReturnStatement
            CurrentSemanticValue = valueStack[0];
            break;

        case 37: // Assignment : IDENTIFIER ASSIGN Expression
            CurrentSemanticValue = new Assignment(
                (string)valueStack[0],
                (ExpressionNode)valueStack[2]);
            break;

        case 38: // WhileLoop : WHILE Expression LOOP Body END
            CurrentSemanticValue = new WhileLoop(
                (ExpressionNode)valueStack[1],
                (List<Statement>)valueStack[3]);
            break;

        case 39: // IfStatement : IF Expression THEN Body ElsePart END
            CurrentSemanticValue = new IfStatement(
                (ExpressionNode)valueStack[1],
                (List<Statement>)valueStack[3],
                (ElsePart)valueStack[4]);
            break;

        case 40: // ElsePart : /* empty */
            CurrentSemanticValue = null;
            break;

        case 41: // ElsePart : ELSE Body
            CurrentSemanticValue = new ElsePart((List<Statement>)valueStack[1]);
            break;

        case 42: // ReturnStatement : RETURN ReturningExpression
            CurrentSemanticValue = new ReturnStatement((ExpressionNode)valueStack[1]);
            break;

        case 43: // ReturningExpression : /* empty */
            CurrentSemanticValue = null;
            break;

        case 44: // ReturningExpression : Expression
            CurrentSemanticValue = valueStack[0];
            break;

        case 45: // Expression : Primary
            CurrentSemanticValue = valueStack[0];
            break;

        case 46: // Expression : ConstructorInvocation
            CurrentSemanticValue = valueStack[0];
            break;

        case 47: // Expression : FunctionalCall
            CurrentSemanticValue = valueStack[0];
            break;

        case 48: // Expression : ExpressionDotSequence
            CurrentSemanticValue = valueStack[0];
            break;

        case 49: // ExpressionDotSequence : Expression
            CurrentSemanticValue = new ExpressionDotSequence(new List<ExpressionNode> { (ExpressionNode)valueStack[0] });
            break;

        case 50: // ExpressionDotSequence : Expression DOT ExpressionDotSequence
            {
                var list = (ExpressionDotSequence)valueStack[2];
                list.Expressions.Insert(0, (ExpressionNode)valueStack[0]);
                CurrentSemanticValue = list;
            }
            break;

        case 51: // ConstructorInvocation : ClassName Arguments
            CurrentSemanticValue = new ConstructorInvocation(
                (string)valueStack[0],
                (List<ExpressionNode>)valueStack[1]);
            break;

        case 52: // FunctionalCall : Expression Arguments
            CurrentSemanticValue = new FunctionalCall(
                (ExpressionNode)valueStack[0],
                (List<ExpressionNode>)valueStack[1]);
            break;

        case 53: // Arguments : LPAREN RPAREN
            CurrentSemanticValue = new List<ExpressionNode>();
            break;

        case 54: // Arguments : LPAREN ExpressionCommaSequence RPAREN
            CurrentSemanticValue = valueStack[1];
            break;

        case 55: // ExpressionCommaSequence : Expression
            CurrentSemanticValue = new List<ExpressionNode> { (ExpressionNode)valueStack[0] };
            break;

        case 56: // ExpressionCommaSequence : Expression DOT ExpressionCommaSequence
            {
                var list = (List<ExpressionNode>)valueStack[2];
                list.Insert(0, (ExpressionNode)valueStack[0]);
                CurrentSemanticValue = list;
            }
            break;

        case 57: // Primary : INTEGER_LITERAL
            CurrentSemanticValue = new IntegerLiteral((int)valueStack[0]);
            break;

        case 58: // Primary : REAL_LITERAL
            CurrentSemanticValue = new RealLiteral((double)valueStack[0]);
            break;

        case 59: // Primary : BOOLEAN_LITERAL
            CurrentSemanticValue = new BooleanLiteral((bool)valueStack[0]);
            break;

        case 60: // Primary : THIS
            CurrentSemanticValue = new ThisExpression();
            break;

        case 61: // Primary : IDENTIFIER
            CurrentSemanticValue = new IdentifierExpression((string)valueStack[0]);
            break;

        default:
            CurrentSemanticValue = valueStack[0];
            break;

    }
#pragma warning restore 162, 1522
  }

  protected override string TerminalToString(int terminal)
  {
    if (aliases != null && aliases.ContainsKey(terminal))
        return aliases[terminal];
    else if (((Tokens)terminal).ToString() != terminal.ToString(CultureInfo.InvariantCulture))
        return ((Tokens)terminal).ToString();
    else
        return CharToString((char)terminal);
  }

#line 228 "OParser.y"
 #line default
}
}
